
/* SKELETON for env functions */
/* Program generated by Cadvanced 4.3.3  Patch level 3 */
#define XSCT_CADVANCED

#define SCT_VERSION_4_3
#include "C:\Telelogic\SDL_TTCN_Suite4.3\sdt\sdtdir\wini386\include\scttypes.h"
#ifdef XINCLUDE_HS_FILE
#include "Model.hs"
#endif
#ifdef XENV_INC
#include XENV_INC
#endif
#include "Model.ifc"
#include "basictypes.ifc"
#include "ctypes.ifc"

#include "../test/battleshipstest.h"
#include "stdlib.h"
#include "conio.h"
#ifdef XTENV
#define RETURN return SDL_Time_Lit((xint32)0,(xint32)0);
#else
#define RETURN return;
#endif
extern int IsSDLQueueEmpty();
extern int PopSDLQueue(TAT_EVENT_INSTANCE*);
extern TAT_EVENT_INSTANCE** QueueToSDL;
extern int WrapInit();
extern int WrapClose();
extern int WrapRun();
extern int battleshipstest_Recv_FINISHSIMULATION(int,int,int,int);
extern int battleshipstest_Recv_ORDERSPEEDREQUEST(int,int,float,int,int);
extern int battleshipstest_Recv_ORDERTURNREQUEST(int,int,int,int,int);
extern int battleshipstest_Recv_ORDERFIREREQUEST(int,int,int,char*,int,int);
extern int battleshipstest_Recv_MESSAGELOG(char*,int,int);
extern int battleshipstest_Recv_MESSAGEERROR(char*,int,int);

/************/
char firereq[100]="";
/***********/

SDL_Time SDL_Clock(void)
{
	SDL_Time temp;
	temp.s = 0;
	temp.ns = 0;
	printf("SDL_Clock()\n");
	return temp;
}



#ifndef XNOGLOBALNODENUMBER
/*---+---------------------------------------------------------------
     xGlobalNodeNumber  extern
-------------------------------------------------------------------*/
#ifndef XENV_NODENUMBER
#define XENV_NODENUMBER return 1;
#endif

extern int xGlobalNodeNumber(void)
{
  /* Assign a unique global system Id to each SDL system in a cluster of systems. */
  XENV_NODENUMBER
}
#endif


#ifndef XNOINITENV
/*---+---------------------------------------------------------------
     xInitEnv  extern
-------------------------------------------------------------------*/
#ifndef XENV_INIT
#define XENV_INIT WrapInit();
#endif

extern void xInitEnv(void)
{
  /* Code to initialize your SDL-system environment may be inserted here */
  XENV_INIT

#ifdef XTRACE
  xPrintString("xInitEnv called\n");
#endif
}
#endif


#ifndef XNOCLOSEENV
/*---+---------------------------------------------------------------
     xCloseEnv  extern
-------------------------------------------------------------------*/
#ifndef XENV_CLOSE
#define XENV_CLOSE WrapClose();
#endif

extern void xCloseEnv(void)
{
  /* Code to bring down the environment in a controlled manner
     may be inserted here. */
  XENV_CLOSE

#ifdef XTRACE
  xPrintString("xCloseEnv called\n");
#endif
}
#endif


/*---+---------------------------------------------------------------
     xOutEnv  extern
-------------------------------------------------------------------*/
extern void xOutEnv( xSignalNode *SignalOut )
{
	printf("xOutEnv():     ");
	printf("Received %s",(*SignalOut)->NameNode->Name);

	if(!strcmp("FinishSimulation",(*SignalOut)->NameNode->Name))
	{
		printf("(%d,%d)\n",((yPDP_FinishSimulation)(*SignalOut))->Param1,((yPDP_FinishSimulation)(*SignalOut))->Param2);
		battleshipstest_Recv_FINISHSIMULATION(((yPDP_FinishSimulation)(*SignalOut))->Param1,((yPDP_FinishSimulation)(*SignalOut))->Param2,TAT_I_STRATEGY_ID,TAT_I_SIMULATOR_ID);
	}
	if(!strcmp("OrderSpeedRequest",(*SignalOut)->NameNode->Name))
	{
		printf("(%d,%d,%f)\n",((yPDP_OrderSpeedRequest)(*SignalOut))->Param1,((yPDP_OrderSpeedRequest)(*SignalOut))->Param2,((yPDP_OrderSpeedRequest)(*SignalOut))->Param3);
		battleshipstest_Recv_ORDERSPEEDREQUEST(((yPDP_OrderSpeedRequest)(*SignalOut))->Param1,((yPDP_OrderSpeedRequest)(*SignalOut))->Param2,((yPDP_OrderSpeedRequest)(*SignalOut))->Param3,TAT_I_STRATEGY_ID,TAT_I_SIMULATOR_ID);
	}
	if(!strcmp("OrderTurnRequest",(*SignalOut)->NameNode->Name))
	{
		printf("(%d,%d,%d)\n",((yPDP_OrderTurnRequest)(*SignalOut))->Param1,((yPDP_OrderTurnRequest)(*SignalOut))->Param2,((yPDP_OrderTurnRequest)(*SignalOut))->Param3);
		battleshipstest_Recv_ORDERTURNREQUEST(((yPDP_OrderTurnRequest)(*SignalOut))->Param1,((yPDP_OrderTurnRequest)(*SignalOut))->Param2,((yPDP_OrderTurnRequest)(*SignalOut))->Param3,TAT_I_STRATEGY_ID,TAT_I_SIMULATOR_ID);
	}
	if(!strcmp("OrderFireRequest",(*SignalOut)->NameNode->Name))
	{
		int i;
		char* temp;
		tStringShotsList_yrec *p;
		int len = ((yPDP_OrderFireRequest)(*SignalOut))->Param4.Length;
		if(  len != 0 && ((yPDP_OrderFireRequest)(*SignalOut))->Param4.First != NULL && ((yPDP_OrderFireRequest)(*SignalOut))->Param4.IsAssigned != 0)
		{
			temp = malloc(sizeof(char)*100);
			sprintf(firereq,"(. ");
			p = ((yPDP_OrderFireRequest)(*SignalOut))->Param4.First;
			for(i=0;i<len;i++)
			{
				if(i == len - 1)
					sprintf(temp,"(. %d, %d .)",p->Data.x,p->Data.y);
				else
					sprintf(temp,"(. %d, %d .), ",p->Data.x,p->Data.y);
				strcat(firereq,temp);
				p = p->Suc;
			}
			strcat(firereq," .)");
			printf("(%d,%d,%d,%s)\n",((yPDP_OrderFireRequest)(*SignalOut))->Param1,((yPDP_OrderFireRequest)(*SignalOut))->Param2,((yPDP_OrderFireRequest)(*SignalOut))->Param3,firereq);
			battleshipstest_Recv_ORDERFIREREQUEST(((yPDP_OrderFireRequest)(*SignalOut))->Param1,((yPDP_OrderFireRequest)(*SignalOut))->Param2,((yPDP_OrderFireRequest)(*SignalOut))->Param3,firereq,TAT_I_STRATEGY_ID,TAT_I_SIMULATOR_ID);
			free(temp);
		}

		
	}
	if(!strcmp("messageLog",(*SignalOut)->NameNode->Name))
	{
		printf("()\n",((yPDP_messageLog)(*SignalOut))->Param1);
		battleshipstest_Recv_MESSAGELOG(((yPDP_messageLog)(*SignalOut))->Param1,TAT_I_STRATEGY_ID,TAT_I_SIMULATOR_ID);
	}
	if(!strcmp("messageError",(*SignalOut)->NameNode->Name))
	{
		printf("()\n",((yPDP_messageError)(*SignalOut))->Param1);
		battleshipstest_Recv_MESSAGEERROR(((yPDP_messageError)(*SignalOut))->Param1,TAT_I_STRATEGY_ID,TAT_I_SIMULATOR_ID);
	}
}
/*---+---------------------------------------------------------------
     xInEnv  extern
-------------------------------------------------------------------*/
#ifndef XTENV
extern void xInEnv ( SDL_Time Time_for_next_event )
#else
extern SDL_Duration xInEnv ( SDL_Time Time_for_next_event )
#endif
{
	xSignalNode SignalIn;
	TAT_EVENT_INSTANCE event;

	char *str;
	char *token;
	int ntokens = 0;
	int nships;
	int val = -1;
	int ship,i,j,ii,jj,len,lent,lent2,var;
	char *token2;
	/*ShipCurrentstate vars*/
	tStringShipCurrentState vStringShipCurrentState;
	tStringShipCurrentState_yrec *vStringShipCurrentState_yrec;
	tArrayAmountAmmunition* vAmmunition;
	/*VisibleShip vars*/
	tStringEnemyShip vStringEnemyShip;
	tStringEnemyShip_yrec *vStringEnemyShip_yrec;

	if(WrapRun() && IsSDLQueueEmpty())
		SDL_Halt();
	printf("xInEnv()");
	if (!IsSDLQueueEmpty())
	{
		PopSDLQueue(&event);
		switch (event.eventID)
		{
			case TAT_S_INITDATACOMPLETE_ID:
			{
				printf(" :     Sent InitDataComplete\n");
				SignalIn = xGetSignal(InitDataComplete,xNotDefPId,xEnv);


				SDL_Output(SignalIn xSigPrioPar(xDefaultSignalPrio),(xIdNode *)0);
				break;
			}
			case TAT_S_STARTSIMULATION_ID:
			{
				printf(" :     Sent StartSimulation(%d)\n",((TAT_SIG_STARTSIMULATION*)event.eventData)->Param1);
				SignalIn = xGetSignal(StartSimulation,xNotDefPId,xEnv);

				((yPDef_StartSimulation *)(SignalIn))->Param1=((TAT_SIG_STARTSIMULATION*)event.eventData)->Param1;

				SDL_Output(SignalIn xSigPrioPar(xDefaultSignalPrio),(xIdNode *)0);
				break;
			}
			case TAT_S_DESTROYSHIP_ID:
			{
				printf(" :     Sent DestroyShip(%d,%d,%d)\n",((TAT_SIG_DESTROYSHIP*)event.eventData)->Param1,((TAT_SIG_DESTROYSHIP*)event.eventData)->Param2,((TAT_SIG_DESTROYSHIP*)event.eventData)->Param3);
				SignalIn = xGetSignal(DestroyShip,xNotDefPId,xEnv);

				((yPDef_DestroyShip *)(SignalIn))->Param1=((TAT_SIG_DESTROYSHIP*)event.eventData)->Param1;
				((yPDef_DestroyShip *)(SignalIn))->Param2=((TAT_SIG_DESTROYSHIP*)event.eventData)->Param2;
				((yPDef_DestroyShip *)(SignalIn))->Param3=((TAT_SIG_DESTROYSHIP*)event.eventData)->Param3;

				SDL_Output(SignalIn xSigPrioPar(xDefaultSignalPrio),(xIdNode *)0);
				break;
			}
			case TAT_S_ORDERSPEEDRESPONSE_ID:
			{
				printf(" :     Sent OrderSpeedResponse(%d,%d)\n",((TAT_SIG_ORDERSPEEDRESPONSE*)event.eventData)->Param1,((TAT_SIG_ORDERSPEEDRESPONSE*)event.eventData)->Param2);
				SignalIn = xGetSignal(OrderSpeedResponse,xNotDefPId,xEnv);

				((yPDef_OrderSpeedResponse *)(SignalIn))->Param1=((TAT_SIG_ORDERSPEEDRESPONSE*)event.eventData)->Param1;
				((yPDef_OrderSpeedResponse *)(SignalIn))->Param2=((TAT_SIG_ORDERSPEEDRESPONSE*)event.eventData)->Param2;

				SDL_Output(SignalIn xSigPrioPar(xDefaultSignalPrio),(xIdNode *)0);
				break;
			}
			case TAT_S_ORDERSPEEDREJECT_ID:
			{
				printf(" :     Sent OrderSpeedReject(%d,%d)\n",((TAT_SIG_ORDERSPEEDREJECT*)event.eventData)->Param1,((TAT_SIG_ORDERSPEEDREJECT*)event.eventData)->Param2);
				SignalIn = xGetSignal(OrderSpeedReject,xNotDefPId,xEnv);

				((yPDef_OrderSpeedReject *)(SignalIn))->Param1=((TAT_SIG_ORDERSPEEDREJECT*)event.eventData)->Param1;
				((yPDef_OrderSpeedReject *)(SignalIn))->Param2=((TAT_SIG_ORDERSPEEDREJECT*)event.eventData)->Param2;

				SDL_Output(SignalIn xSigPrioPar(xDefaultSignalPrio),(xIdNode *)0);
				break;
			}
			case TAT_S_ORDERTURNRESPONSE_ID:
			{
				printf(" :     Sent OrderTurnResponse(%d,%d)\n",((TAT_SIG_ORDERTURNRESPONSE*)event.eventData)->Param1,((TAT_SIG_ORDERTURNRESPONSE*)event.eventData)->Param2);
				SignalIn = xGetSignal(OrderTurnResponse,xNotDefPId,xEnv);

				((yPDef_OrderTurnResponse *)(SignalIn))->Param1=((TAT_SIG_ORDERTURNRESPONSE*)event.eventData)->Param1;
				((yPDef_OrderTurnResponse *)(SignalIn))->Param2=((TAT_SIG_ORDERTURNRESPONSE*)event.eventData)->Param2;

				SDL_Output(SignalIn xSigPrioPar(xDefaultSignalPrio),(xIdNode *)0);
				break;
			}
			case TAT_S_ORDERTURNREJECT_ID:
			{
				printf(" :     Sent OrderTurnReject(%d,%d)\n",((TAT_SIG_ORDERTURNREJECT*)event.eventData)->Param1,((TAT_SIG_ORDERTURNREJECT*)event.eventData)->Param2);
				SignalIn = xGetSignal(OrderTurnReject,xNotDefPId,xEnv);

				((yPDef_OrderTurnReject *)(SignalIn))->Param1=((TAT_SIG_ORDERTURNREJECT*)event.eventData)->Param1;
				((yPDef_OrderTurnReject *)(SignalIn))->Param2=((TAT_SIG_ORDERTURNREJECT*)event.eventData)->Param2;

				SDL_Output(SignalIn xSigPrioPar(xDefaultSignalPrio),(xIdNode *)0);
				break;
			}
			case TAT_S_ORDERFIRERESPONSE_ID:
			{
				printf(" :     Sent OrderFireResponse(%d,%d)\n",((TAT_SIG_ORDERFIRERESPONSE*)event.eventData)->Param1,((TAT_SIG_ORDERFIRERESPONSE*)event.eventData)->Param2);
				SignalIn = xGetSignal(OrderFireResponse,xNotDefPId,xEnv);

				((yPDef_OrderFireResponse *)(SignalIn))->Param1=((TAT_SIG_ORDERFIRERESPONSE*)event.eventData)->Param1;
				((yPDef_OrderFireResponse *)(SignalIn))->Param2=((TAT_SIG_ORDERFIRERESPONSE*)event.eventData)->Param2;

				SDL_Output(SignalIn xSigPrioPar(xDefaultSignalPrio),(xIdNode *)0);
				break;
			}
			case TAT_S_ORDERFIREREJECT_ID:
			{
				printf(" :     Sent OrderFireReject(%d,%d)\n",((TAT_SIG_ORDERFIREREJECT*)event.eventData)->Param1,((TAT_SIG_ORDERFIREREJECT*)event.eventData)->Param2);
				SignalIn = xGetSignal(OrderFireReject,xNotDefPId,xEnv);

				((yPDef_OrderFireReject *)(SignalIn))->Param1=((TAT_SIG_ORDERFIREREJECT*)event.eventData)->Param1;
				((yPDef_OrderFireReject *)(SignalIn))->Param2=((TAT_SIG_ORDERFIREREJECT*)event.eventData)->Param2;

				SDL_Output(SignalIn xSigPrioPar(xDefaultSignalPrio),(xIdNode *)0);
				break;
			}
			case TAT_S_SHIPSCURRENTSTATE_ID:
			{
				printf(" :     Sent ShipsCurrentState(%d,%s)\n",((TAT_SIG_SHIPSCURRENTSTATE*)event.eventData)->Param1,((TAT_SIG_SHIPSCURRENTSTATE*)event.eventData)->Param2);
				SignalIn = xGetSignal(ShipsCurrentState,xNotDefPId,xEnv);

				((yPDef_ShipsCurrentState *)(SignalIn))->Param1=((TAT_SIG_SHIPSCURRENTSTATE*)event.eventData)->Param1;
				/************************************************************/
				str=((TAT_SIG_SHIPSCURRENTSTATE*)event.eventData)->Param2;

				/*ShipCurrentstate code*/
				/**************************************/
				   len = strlen(str);
				   for(i=0;i<len;i++)
					   if(str[i]==',')
						   ntokens++;
					if(ntokens == 11)
						nships = 1;
					else
						nships = (ntokens+1)/12;

				   vStringShipCurrentState_yrec = malloc(sizeof(tStringShipCurrentState_yrec)*nships);
				   vAmmunition = malloc(sizeof(tArrayAmountAmmunition)*nships);
				   jj=0;
				   for(ship=0;ship<nships;ship++)
				   {
					   for(var=1;var<=12;var++)
					   {
						ii=0;
						token = malloc(sizeof(char)*(strlen(str)+1));
						while(str[jj]!=',' && str[jj]!='\0')
							token[ii++]=str[jj++];
						jj++;
						token[ii] = '\0';
						//printf("%s\n",token);
						i=0;
						lent = strlen(token);
						while(i<lent)
						{
							if(i<lent+2)
								if((token[i]=='(' && (token[i+1]=='.' || token[i+1]==':')) || ((token[i]=='.' || token[i]==':') && (token[i+1]==')')))
								{
									token[i]=' ';
									token[i+1]=' ';
									i+=2;
								}
								else
									i++;

						 }
						lent2 = 0;
						for(i=0;i<lent;i++)
							if(token[i]!=' ')
								lent2++;
						token2 = (char *)malloc(sizeof(char)*(lent2+1));
						j = 0;
						for(i=0;i<lent;i++)
							if(token[i]!=' ')
							{
								token2[j] = token[i];
								j++;
							}
							token2[lent2] = '\0';
						val=-1;
						sscanf(token2,"%d",&val);
						switch(var)
						{
						case 1:
							sscanf(token2,"%d",&vStringShipCurrentState_yrec[ship].Data.ShipId);
							break;
						case 2:
							sscanf(token2,"%d",&vStringShipCurrentState_yrec[ship].Data.StrategyId);
							break;
						case 3:
							if(!strcmp(token2,"BATTLESHIP"))
								vStringShipCurrentState_yrec[ship].Data.TypeShip = BATTLESHIP;
							if(!strcmp(token2,"CRUISER"))
								vStringShipCurrentState_yrec[ship].Data.TypeShip = CRUISER;
							if(!strcmp(token2,"DESTROYER"))
								vStringShipCurrentState_yrec[ship].Data.TypeShip = DESTROYER;
							if(!strcmp(token2,"MISSILE_CUTTER"))
								vStringShipCurrentState_yrec[ship].Data.TypeShip = MISSILE_CUTTER;
							if(!strcmp(token2,"REPAIR_BOAT"))
								vStringShipCurrentState_yrec[ship].Data.TypeShip = REPAIR_BOAT;
							break;
						case 4:
							sscanf(token2,"%d",&vStringShipCurrentState_yrec[ship].Data.Speed);
							break;
						case 5:
							if(!strcmp(token2,"NORTH"))
								vStringShipCurrentState_yrec[ship].Data.Heading = NORTH;
							if(!strcmp(token2,"NORTH_EAST"))
								vStringShipCurrentState_yrec[ship].Data.Heading = NORTH_EAST;
							if(!strcmp(token2,"EAST"))
								vStringShipCurrentState_yrec[ship].Data.Heading = EAST;
							if(!strcmp(token2,"SOUTH_EAST"))
								vStringShipCurrentState_yrec[ship].Data.Heading = SOUTH_EAST;
							if(!strcmp(token2,"SOUTH"))
								vStringShipCurrentState_yrec[ship].Data.Heading = SOUTH;
							if(!strcmp(token2,"SOUTH_WEST"))
								vStringShipCurrentState_yrec[ship].Data.Heading = SOUTH_WEST;
							if(!strcmp(token2,"WEST"))
								vStringShipCurrentState_yrec[ship].Data.Heading = WEST;
							if(!strcmp(token2,"NORTH_WEST"))
								vStringShipCurrentState_yrec[ship].Data.Heading = NORTH_WEST;
							break;
						case 6:
							sscanf(token2,"%d",&vStringShipCurrentState_yrec[ship].Data.Resource);
							break;
						case 7:
							sscanf(token2,"%d",&vStringShipCurrentState_yrec[ship].Data.Coordinates.x);
							break;
						case 8:
							sscanf(token2,"%d",&vStringShipCurrentState_yrec[ship].Data.Coordinates.y);
							break;
						case 9:
							sscanf(token2,"%d",&vAmmunition[ship].A[0]);
							break;
						case 10:
							sscanf(token2,"%d",&vAmmunition[ship].A[1]);
							break;
						case 11:
							sscanf(token2,"%d",&vAmmunition[ship].A[2]);
							break;
						case 12:
							sscanf(token2,"%d",&vAmmunition[ship].A[3]);
							break;
						default:
							break;
						}
						free(token2);
						free(token);
					   }
					   vStringShipCurrentState_yrec[ship].Data.Ammunition = vAmmunition[ship];
						if(ship==nships-1)
							vStringShipCurrentState_yrec[ship].Suc = NULL;
						else
							vStringShipCurrentState_yrec[ship].Suc = &vStringShipCurrentState_yrec[ship+1];
				   }
				vStringShipCurrentState.First = &vStringShipCurrentState_yrec[0];
				vStringShipCurrentState.Last = &vStringShipCurrentState_yrec[nships-1];
				vStringShipCurrentState.Length = nships;
				vStringShipCurrentState.IsAssigned = 1;

				((yPDef_ShipsCurrentState *)(SignalIn))->Param2 = vStringShipCurrentState;

				SDL_Output(SignalIn xSigPrioPar(xDefaultSignalPrio),(xIdNode *)0);
				break;
			}
			case TAT_S_VISIBLESHIP_ID:
			{
				printf(" :     Sent VisibleShip(%d,%s)\n",((TAT_SIG_VISIBLESHIP*)event.eventData)->Param1,((TAT_SIG_VISIBLESHIP*)event.eventData)->Param2);
				SignalIn = xGetSignal(VisibleShip,xNotDefPId,xEnv);

				((yPDef_VisibleShip *)(SignalIn))->Param1=((TAT_SIG_VISIBLESHIP*)event.eventData)->Param1;
				str = ((TAT_SIG_VISIBLESHIP*)event.eventData)->Param2;
				/**********************************************************/
				/*VisibleShip code*/
				/**************************************/
				   len = strlen(str);
				   for(i=0;i<len;i++)
					   if(str[i]==',')
						   ntokens++;
					if(ntokens == 5)
						nships = 1;
					else
						nships = (ntokens+1)/6;

				   vStringEnemyShip_yrec = malloc(sizeof(tStringEnemyShip_yrec)*nships);
				   jj=0;
				   for(ship=0;ship<nships;ship++)
				   {
					   for(var=1;var<=7;var++)
					   {
						ii=0;
						token = malloc(sizeof(char)*(strlen(str)+1));
						while(str[jj]!=',' && str[jj]!='\0')
							token[ii++]=str[jj++];
						jj++;
						token[ii] = '\0';
						i=0;
						lent = strlen(token);
						while(i<lent)
						{
							if(i<lent+2)
								if((token[i]=='(' && (token[i+1]=='.' || token[i+1]==':')) || ((token[i]=='.' || token[i]==':') && (token[i+1]==')')))
								{
									token[i]=' ';
									token[i+1]=' ';
									i+=2;
								}
								else
									i++;

						 }
						lent2 = 0;
						for(i=0;i<lent;i++)
							if(token[i]!=' ')
								lent2++;
						token2 = (char *)malloc(sizeof(char)*(lent2+1));
						j = 0;
						for(i=0;i<lent;i++)
							if(token[i]!=' ')
							{
								token2[j] = token[i];
								j++;
							}
							token2[lent2] = '\0';
						val=-1;
						sscanf(token2,"%d",&val);
						switch(var)
						{
						case 1:
							sscanf(token2,"%d",&vStringEnemyShip_yrec[ship].Data.ShipId);
							break;
						case 2:
							sscanf(token2,"%d",&vStringEnemyShip_yrec[ship].Data.StrategyId);
							break;
						case 3:
							if(!strcmp(token2,"BATTLESHIP"))
								vStringEnemyShip_yrec[ship].Data.TypeShip = BATTLESHIP;
							if(!strcmp(token2,"CRUISER"))
								vStringEnemyShip_yrec[ship].Data.TypeShip = CRUISER;
							if(!strcmp(token2,"DESTROYER"))
								vStringEnemyShip_yrec[ship].Data.TypeShip = DESTROYER;
							if(!strcmp(token2,"MISSILE_CUTTER"))
								vStringEnemyShip_yrec[ship].Data.TypeShip = MISSILE_CUTTER;
							if(!strcmp(token2,"REPAIR_BOAT"))
								vStringEnemyShip_yrec[ship].Data.TypeShip = REPAIR_BOAT;
							break;
						case 4:
							sscanf(token2,"%d",&vStringEnemyShip_yrec[ship].Data.Speed);
							break;
						case 5:
							if(!strcmp(token2,"NORTH"))
								vStringEnemyShip_yrec[ship].Data.Heading = NORTH;
							if(!strcmp(token2,"NORTH_EAST"))
								vStringEnemyShip_yrec[ship].Data.Heading = NORTH_EAST;
							if(!strcmp(token2,"EAST"))
								vStringEnemyShip_yrec[ship].Data.Heading = EAST;
							if(!strcmp(token2,"SOUTH_EAST"))
								vStringEnemyShip_yrec[ship].Data.Heading = SOUTH_EAST;
							if(!strcmp(token2,"SOUTH"))
								vStringEnemyShip_yrec[ship].Data.Heading = SOUTH;
							if(!strcmp(token2,"SOUTH_WEST"))
								vStringEnemyShip_yrec[ship].Data.Heading = SOUTH_WEST;
							if(!strcmp(token2,"WEST"))
								vStringEnemyShip_yrec[ship].Data.Heading = WEST;
							if(!strcmp(token2,"NORTH_WEST"))
								vStringEnemyShip_yrec[ship].Data.Heading = NORTH_WEST;
							break;
						case 6:
							sscanf(token2,"%d",&vStringEnemyShip_yrec[ship].Data.Coordinates.x);
							break;
						case 7:
							sscanf(token2,"%d",&vStringEnemyShip_yrec[ship].Data.Coordinates.y);
							break;
						default:
							break;
						}
						free(token2);
						free(token);
					   }
						if(ship==nships-1)
							vStringEnemyShip_yrec[ship].Suc = NULL;
						else
							vStringEnemyShip_yrec[ship].Suc = &vStringEnemyShip_yrec[ship+1];
				   }
				vStringEnemyShip.First = &vStringEnemyShip_yrec[0];
				vStringEnemyShip.Last = &vStringEnemyShip_yrec[nships-1];
				vStringEnemyShip.Length = nships;
				vStringEnemyShip.IsAssigned = 1;

				/****************************************************************/
				((yPDef_VisibleShip *)(SignalIn))->Param2 = vStringEnemyShip;

				SDL_Output(SignalIn xSigPrioPar(xDefaultSignalPrio),(xIdNode *)0);
				break;
			}
			case TAT_S_STRATEGYVICTORY_ID:
			{
				printf(" :     Sent StrategyVictory()\n",((TAT_SIG_STRATEGYVICTORY*)event.eventData)->Param1);
				SignalIn = xGetSignal(StrategyVictory,xNotDefPId,xEnv);

				((yPDef_StrategyVictory *)(SignalIn))->Param1=((TAT_SIG_STRATEGYVICTORY*)event.eventData)->Param1;

				SDL_Output(SignalIn xSigPrioPar(xDefaultSignalPrio),(xIdNode *)0);
				break;
			}
			case TAT_S_STRATEGYLOSE_ID:
			{
				printf(" :     Sent StrategyLose()\n",((TAT_SIG_STRATEGYLOSE*)event.eventData)->Param1);
				SignalIn = xGetSignal(StrategyLose,xNotDefPId,xEnv);

				((yPDef_StrategyLose *)(SignalIn))->Param1=((TAT_SIG_STRATEGYLOSE*)event.eventData)->Param1;

				SDL_Output(SignalIn xSigPrioPar(xDefaultSignalPrio),(xIdNode *)0);
				break;
			}
			default:
			{
				puts("ERROR: (wrapper) unknown signal to transmit to model.");
			}
		}
	}
	else
		printf("\n");
	RETURN
}
